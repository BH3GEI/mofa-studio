"""
Content Converter Backend

A simple converter for audio, video, and text formats.
"""

import sys
import json
import uuid
import time
from pathlib import Path
from http.server import HTTPServer, SimpleHTTPRequestHandler
from urllib.parse import parse_qs, urlparse
import threading

# Mock job storage
jobs = {}

# Supported formats
AUDIO_FORMATS = {'.mp3', '.wav', '.m4a', '.flac', '.ogg', '.aac'}
VIDEO_FORMATS = {'.mp4', '.mkv', '.avi', '.mov', '.webm'}
TEXT_FORMATS = {'.txt', '.md', '.json', '.srt'}

ALL_FORMATS = AUDIO_FORMATS | VIDEO_FORMATS | TEXT_FORMATS


def get_file_type(ext):
    """Get file type from extension."""
    ext = ext.lower()
    if ext in AUDIO_FORMATS:
        return 'audio'
    if ext in VIDEO_FORMATS:
        return 'video'
    if ext in TEXT_FORMATS:
        return 'text'
    return 'unknown'


def process_job_mock(job_id, source_type, target_type):
    """Mock job processing."""
    job = jobs[job_id]

    try:
        job['status'] = 'processing'
        job['progress'] = 10
        job['stage'] = 'Analyzing input...'

        time.sleep(0.5)
        job['progress'] = 30
        job['stage'] = 'Converting...'

        time.sleep(1)
        job['progress'] = 70
        job['stage'] = 'Finalizing...'

        time.sleep(0.5)
        job['progress'] = 100
        job['status'] = 'completed'
        job['stage'] = 'Done'

        # Generate mock result based on conversion type
        if target_type == 'text':
            job['result'] = {
                'type': 'text',
                'content': 'This is a mock transcription of the audio content. '
                          'In a real implementation, this would be generated by '
                          'a speech-to-text model like Whisper.',
                'word_count': 24,
                'language': 'en'
            }
        elif target_type == 'audio':
            job['result'] = {
                'type': 'audio',
                'url': f'/mock/output_{job_id}.mp3',
                'duration': 120,
                'format': 'mp3'
            }
        elif target_type == 'video':
            job['result'] = {
                'type': 'video',
                'url': f'/mock/output_{job_id}.mp4',
                'duration': 120,
                'format': 'mp4',
                'resolution': '1920x1080'
            }

    except Exception as e:
        job['status'] = 'error'
        job['error'] = str(e)


class ConverterHandler(SimpleHTTPRequestHandler):
    def __init__(self, *args, **kwargs):
        self.directory = str(Path(__file__).parent / 'static')
        super().__init__(*args, directory=self.directory, **kwargs)

    def do_GET(self):
        parsed = urlparse(self.path)

        if parsed.path == '/api/info':
            self._json_response({
                'name': 'Content Converter',
                'version': '1.0.0',
                'formats': {
                    'audio': list(AUDIO_FORMATS),
                    'video': list(VIDEO_FORMATS),
                    'text': list(TEXT_FORMATS)
                }
            })
        elif parsed.path == '/api/status':
            params = parse_qs(parsed.query)
            job_id = params.get('id', [None])[0]
            if job_id and job_id in jobs:
                self._json_response(jobs[job_id])
            else:
                self._json_response({'error': 'Job not found'}, 404)
        else:
            super().do_GET()

    def do_POST(self):
        parsed = urlparse(self.path)

        if parsed.path == '/api/convert':
            self._handle_convert()
        elif parsed.path == '/api/upload':
            self._handle_upload()
        else:
            self._json_response({'error': 'Not found'}, 404)

    def _handle_convert(self):
        """Handle conversion request."""
        data = self._read_json()

        if not data:
            self._json_response({'error': 'Invalid JSON'}, 400)
            return

        source_type = data.get('source_type')
        target_type = data.get('target_type')
        content = data.get('content', '')

        if not source_type or not target_type:
            self._json_response({'error': 'Missing source or target type'}, 400)
            return

        job_id = str(uuid.uuid4())[:8]
        jobs[job_id] = {
            'id': job_id,
            'source_type': source_type,
            'target_type': target_type,
            'status': 'queued',
            'progress': 0,
            'stage': 'Queued',
            'result': None,
            'error': None
        }

        # Start processing in background
        thread = threading.Thread(
            target=process_job_mock,
            args=(job_id, source_type, target_type)
        )
        thread.start()

        self._json_response({'job_id': job_id})

    def _handle_upload(self):
        """Handle file upload."""
        content_type = self.headers.get('Content-Type', '')

        if 'multipart/form-data' not in content_type:
            self._json_response({'error': 'Expected multipart/form-data'}, 400)
            return

        # Parse boundary
        boundary = None
        for part in content_type.split(';'):
            part = part.strip()
            if part.startswith('boundary='):
                boundary = part[9:].strip('"')
                break

        if not boundary:
            self._json_response({'error': 'No boundary found'}, 400)
            return

        content_length = int(self.headers.get('Content-Length', 0))
        body = self.rfile.read(content_length)

        boundary_bytes = f'--{boundary}'.encode()
        parts = body.split(boundary_bytes)

        file_data = None
        filename = 'upload'
        target_type = None

        for part in parts:
            if b'Content-Disposition' not in part:
                continue

            if b'\r\n\r\n' not in part:
                continue

            header_section, content = part.split(b'\r\n\r\n', 1)
            header_text = header_section.decode('utf-8', errors='ignore')

            # Clean up content
            if content.endswith(b'\r\n'):
                content = content[:-2]
            if content.endswith(b'--'):
                content = content[:-2]
            if content.endswith(b'\r\n'):
                content = content[:-2]

            if 'name="file"' in header_text:
                file_data = content
                for line in header_text.split('\r\n'):
                    if 'filename=' in line:
                        start = line.find('filename="') + 10
                        end = line.find('"', start)
                        if end > start:
                            filename = line[start:end]
            elif 'name="target"' in header_text:
                target_type = content.decode('utf-8').strip()

        if not file_data:
            self._json_response({'error': 'No file provided'}, 400)
            return

        ext = Path(filename).suffix.lower()
        if ext not in ALL_FORMATS:
            self._json_response({
                'error': f'Unsupported format: {ext}',
                'supported': list(ALL_FORMATS)
            }, 400)
            return

        source_type = get_file_type(ext)

        job_id = str(uuid.uuid4())[:8]
        jobs[job_id] = {
            'id': job_id,
            'filename': filename,
            'source_type': source_type,
            'target_type': target_type or 'text',
            'status': 'queued',
            'progress': 0,
            'stage': 'Queued',
            'result': None,
            'error': None
        }

        # Start processing
        thread = threading.Thread(
            target=process_job_mock,
            args=(job_id, source_type, target_type or 'text')
        )
        thread.start()

        self._json_response({'job_id': job_id})

    def _read_json(self):
        try:
            length = int(self.headers.get('Content-Length', 0))
            body = self.rfile.read(length)
            return json.loads(body.decode('utf-8'))
        except:
            return None

    def _json_response(self, data, status=200):
        body = json.dumps(data, ensure_ascii=False).encode('utf-8')
        self.send_response(status)
        self.send_header('Content-Type', 'application/json; charset=utf-8')
        self.send_header('Content-Length', str(len(body)))
        self.send_header('Access-Control-Allow-Origin', '*')
        self.end_headers()
        self.wfile.write(body)

    def do_OPTIONS(self):
        self.send_response(200)
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        self.end_headers()

    def log_message(self, format, *args):
        print(f'[Converter] {args[0]}')


def run_server(port: int = 8080):
    server = HTTPServer(('127.0.0.1', port), ConverterHandler)
    print(f'Content Converter server running on http://127.0.0.1:{port}')
    server.serve_forever()


if __name__ == '__main__':
    port = int(sys.argv[1]) if len(sys.argv) > 1 else 8080
    run_server(port)
